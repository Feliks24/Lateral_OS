
IDEA

start.c
	do the init of everything
	init TCB for main loop
	run empty loop

timer.c: every timer interrupt
	read if there's a new input signal
	if input signal
		make a tcb; append to current
		with state not running
		basically call scheduler
	call scheduler for next thread
	scheduler decideds next or not, so gives 0 or 1
		when 1 move to next
	if 0 -> just continue
	if 1 -> 
		save all registers to prev.SP
		load all register from current.SP
		resume

scheduler.c
	responible for maintaining runqueu
	malloc new tcbs with important data

	make it so that if new thread forge a ready tcb and just append

new thread made
	new tcb has to be initialized 	


void init_thread_stack(TCB_t *tcb, unsigned int *stack_base, void (*thread_func)(void)) {
    // 1. Point to the very end of the stack array (it grows down)
    unsigned int *stk = &stack_base[STACK_SIZE];

    // --- Place registers on stack in the EXACT order your assembly expects ---

    // [1] Return Address (PC): Where the thread starts executing
    *(--stk) = (unsigned int)thread_func; 

    // [2] Link Register (LR): Where the thread goes if it ever 'returns'
    // Usually points to a "thread_exit" function to prevent crashes
    *(--stk) = (unsigned int)0; 

    // [3] Stack Pointer (R13) and R12-R1
    for (int i = 0; i < 14; i++) {
        *(--stk) = 0; // Initialize R13_usr, R12, R11...R1 with 0
    }

    // [4] R0: Can be used to pass a 'void *arg' to the thread function
    *(--stk) = 0; 

    // [5] SPSR: This is critical. 
    // Set to 0x1F (System Mode) or 0x10 (User Mode)
    // IMPORTANT: Make sure the 'I' bit is 0 so interrupts are ENABLED in the thread!
    *(--stk) = 0x1F; 

    // 2. Save the final stack pointer into the TCB
    tcb->stack_ptr = stk;
}






MMU

-> make L1 table
-> put L1-table point in TTB
	-> page 49
	-> CP15 Register 2, TTB
	-> Pointer[31:14]
-> set domain access control
-> enable MMU
	-> page 48
	CP15 register 1, control
	M bit = 1 -> MMU enable


-> reduce complexity
	-> deactivate caches in CP15 
	-> set C and B bits to 0 in L1


L1 Layout
-> AP = 11 -> vollzugriff
-> corrently AP = 01 -> user kein zugriff
4096 x 4 bytes

section base address[31:20]
	-> ??
	-> do some non 1:1 map idk
	-> Identity mapping for
		-> Internal memories
		-> EBI chip select 1/ SDRAMC 
		-> Internal Peripherals
	-> maybe map 0x8000 -> 0x4000
	
empty[19:12]
AP[11,10]
	-> first 11, then 01
empty[9]
Domain[8:5]
	-> perhaps 0000
	-> groups an entry into some domain from 0-15
	-> domain access can be changed
		-> see page 50
Bits[4:0]
	-> 1 0 0 1 0
	-> 1 C B 1 0
		-> last 1 0 stands for SBA
		-> section base address
	-> set C B = 0 0


Some memory notes

Eintrittspunkts as per kernel.lds: 0x20000000
#define STACK_BOTTOM 0x24000000
#define INTERNAL_RAM ((void *)     0x00200000)











































