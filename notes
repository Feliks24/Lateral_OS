
IDEA

start.c
	do the init of everything
	init TCB for main loop
	run empty loop

timer.c: every timer interrupt
	read if there's a new input signal
	if input signal
		make a tcb; append to current
		with state not running
		basically call scheduler
	call scheduler for next thread
	scheduler decideds next or not, so gives 0 or 1
		when 1 move to next
	if 0 -> just continue
	if 1 -> 
		save all registers to prev.SP
		load all register from current.SP
		resume

scheduler.c
	responible for maintaining runqueu
	malloc new tcbs with important data

	make it so that if new thread forge a ready tcb and just append

new thread made
	new tcb has to be initialized 	


void init_thread_stack(TCB_t *tcb, unsigned int *stack_base, void (*thread_func)(void)) {
    // 1. Point to the very end of the stack array (it grows down)
    unsigned int *stk = &stack_base[STACK_SIZE];

    // --- Place registers on stack in the EXACT order your assembly expects ---

    // [1] Return Address (PC): Where the thread starts executing
    *(--stk) = (unsigned int)thread_func; 

    // [2] Link Register (LR): Where the thread goes if it ever 'returns'
    // Usually points to a "thread_exit" function to prevent crashes
    *(--stk) = (unsigned int)0; 

    // [3] Stack Pointer (R13) and R12-R1
    for (int i = 0; i < 14; i++) {
        *(--stk) = 0; // Initialize R13_usr, R12, R11...R1 with 0
    }

    // [4] R0: Can be used to pass a 'void *arg' to the thread function
    *(--stk) = 0; 

    // [5] SPSR: This is critical. 
    // Set to 0x1F (System Mode) or 0x10 (User Mode)
    // IMPORTANT: Make sure the 'I' bit is 0 so interrupts are ENABLED in the thread!
    *(--stk) = 0x1F; 

    // 2. Save the final stack pointer into the TCB
    tcb->stack_ptr = stk;
}
